#' Phaseplane analysis of a system of ODEs
#'
#' \code{bifurcation}
#'
#'
#'   bifurcation(model, state, parms, inlist = NULL)
#'
#'
#' @param   model  (function, required)
#' \preformatted{}
#'               An R-function that computes the values of the derivatives
#'               in the ODE system (the model definition) at time t.
#'               The model must be defined as: model <- function(t, state, parms),
#'               where t is the current time point in the integration, state is
#'               the current value of the variables in the ODE #' system and
#'               parms is a vector or list of parameters.
#'               The return value of func should be a list, whose first and single
#'               element is a vector containing the derivatives of y with respect
#'               to time. The derivatives must be specified in the same order as
#'               the state variables state. The vector state and parms should both
#'               have name attributes for all their elements
#'
#' @param   state  (numeric vector, required)
#' \preformatted{}
#'               The initial (state) values for the ODE system. This vector should
#'               have name attributes for all its elements
#'
#' @param   parms  (numeric vector, required)
#' \preformatted{}
#'               The values of the parameters in the ODE system. This vector should
#'               have name attributes for all its elements
#'
#' @param   inlist  (list, optional)
#' \preformatted{}
#'               Providing this argument will load the specified curve list at
#'               startup. Note that the specified list should have a structure as
#'               generated by a previous call to the function. The programs saves
#'               the last computed curve list into a global variable 'CurveList'
#'
#' @return None.
#'
#' @examples
#' \dontrun{
#' # The model has to be specified as a function that returns
#' # the derivatives as a list.
#' model <- function(t, state, parms) {
#'   with(as.list(c(state,parms)), {
#'
#'     dR <- r*R*(1 - R/K) - a*R*N
#'     dN <- c*a*R*N - delta*N
#'
#'     return(list(c(dR, dN)))
#'   })
#' }
#'
#' # The initial state of the system has to be specified as a named vector of state values.
#' state <- c(R=1, N=0.01)
#'
#' # Parameters has to be specified as a named vector of parameters.
#' parms <- c(r=1, K=1, a=1, c=1, delta=0.5)
#'
#' bifurcation(model, state, parms)
#' }
#' @importFrom graphics contour legend lines par plot points text axis mtext persp axTicks segments
#' @importFrom grDevices trans3d
#' @import deSolve rootSolve shiny shinydashboard shinydashboardPlus
#' @importFrom shinyjs useShinyjs click removeClass html
#' @importFrom stats setNames
#' @export
bifurcation <- function(model, state, parms, inlist = NULL) {

  # Get the names of the state variables and the parameters
  statenames <- names(state)
  parmsnames <- names(parms)

  # Numerical options
  initnopts <- list(odemethod = "lsoda", tmax = 1000, tstep = 0.1,
                    args_run = unique(names(c(formals(deSolve::ode), formals(deSolve::lsoda)))),
                    methods_run = as.character(formals(deSolve::ode)$method),
                    rtol = 1e-7, atol = 1e-9, ctol = 1e-8, jacdif = 1.0E-6, maxiter = 100,
                    maxpoints = 500, iszero = 1.0E-5, stepsize = 0.01, minstepsize = 1.0E-5, replotfreq = 10
  )

  # Options for plotting etc.
  initpopts <- vector(mode = "list", 3)
  for (i in 1:length(initpopts)) {
    initpopts[[i]] <- list(xcol = 1, xmin = 0, xmax = 1, logx = 0, xlab = "",
                           ycol = 1, ymin = 0, ymax = 1, logy = 0, ylab = "",
                           y2col = 1, y2min = 0, y2max = 1, logy2 = 0, y2lab = "None", plot3d = 0,
                           lwd = 3, stablesym = 20, unstablesym = 1, bifsym = 8, unstablelty = "dotted", sizeLegend = 1,
                           tcl.len = 0.03, theta = -35,
                           font.main = 2, font.sub = 1,
                           cex.main = 2, cex.lab = 1.4, cex.axis = 1.2, cex.sym = 1.2, biflblpos = 3,
                           colors = c("red","blue","darkgreen","darkorange","darkmagenta",
                                      "gold","darkorchid","aquamarine","deeppink","gray",seq(2,991)),
                           plotmar = c(5,5,2,4))
  }

  initpopts[[1]]$xlab <- "Time"
  initpopts[[1]]$xmax <- initnopts$tmax
  initpopts[[1]]$ylab <- "State variables"
  initpopts[[2]]$xlab <- parmsnames[1]
  initpopts[[2]]$ylab <- "State variables"
  initpopts[[3]]$xlab <- parmsnames[1]
  initpopts[[3]]$ycol <- 2
  initpopts[[3]]$ylab <- parmsnames[2]

  ui <- buildUI(state, parms, initpopts, initnopts)

  # server = function(input, output) { }
  server <- function(input, output, session) {

    # Create the variable curveList as a reactive value, such that the plots will be updated when curveList changes
    curveList <- reactiveValues()

    # If inlist is a list containing elements 'Orbits', 'BifurcationCurves',
    # 'BifurcationBounds', and 'TotalCurves' assume that it is a correct list
    # generated by an earlier call to bifurcation()
    if (!is.null(inlist) && is.list(inlist) &&
        all(c("Orbits", "BifurcationCurves", "BifurcationBounds", "TotalCurves") %in% names(inlist))) {
      curveList$Orbits <- inlist$Orbits
      curveList$BifurcationCurves <- inlist$BifurcationCurves
      curveList$BifurcationBounds <- inlist$BifurcationBounds
      curveList$TotalCurves <- inlist$TotalCurves
    } else {
      curveList$Orbits <- list()
      curveList$BifurcationCurves <- list()
      curveList$BifurcationBounds <- list()
      curveList$TotalCurves <- 0
    }
    curveListNames <- c('Orbits', 'BifurcationCurves', 'BifurcationBounds', 'TotalCurves')

    # Create the variable plotopts as a reactive value, such that the plots will be updated when plotopts changes
    plotopts <- reactiveValues()
    plotopts$Orbits <- initpopts[[1]]
    plotopts$BifurcationCurves <- initpopts[[2]]
    plotopts$BifurcationBounds <- initpopts[[3]]

    # Create the variable numopts as a reactive value, even though computations will only start after a button push
    numopts <- reactiveValues()
    lapply((1:length(initnopts)), function(i) {numopts[[(names(initnopts)[[i]])]] <- initnopts[[i]]})

    # Create the variable consoleLog as a reactive value, such that the console will be updated when text is added to it
    consoleLog <- reactiveVal()

    busyComputing <- reactiveVal(0)
    updatePlot <- reactiveVal(0)
    curveDirection <- reactiveVal(0)
    changeCurveMenu <- reactiveVal(0)

    # React to changes in curveList or plotopts, by replotting the current plot
    observe({
      curtab <- as.numeric(input$plottab)
      curtabname <- curveListNames[curtab]
      if (as.numeric(updatePlot()) == 0) return(NULL)

      output[[paste0("plot", curtab)]] <- renderPlot({
        if (curtab == 1) biforbitplot(session, curveList[[curtabname]], plotopts[[curtabname]])
        else if (curtab == 2) bif1parplot(session, curveList[[curtabname]], plotopts[[curtabname]])
        else bif2parplot(session, curveList[[curtabname]], plotopts[[curtabname]])
      },
      height = function() {0.75*session$clientData[[paste0("output_plot", curtab, "_width")]]},
      width = function() {0.99*session$clientData[[paste0("output_plot", curtab, "_width")]]})
      updatePlot(0)

      # Update the console log
      consoleLog(session$userData$alltext)
    })

    # React to changes in curveList by updating the special point selection menu
    observe({
      if (as.numeric(isolate(busyComputing())) == 1) return(NULL)

      if (as.numeric(changeCurveMenu()) == 0) return(NULL)
      else if (as.numeric(changeCurveMenu()) == 1)
        updateSpecialPointsList(session, reactiveValuesToList(curveList), as.numeric(isolate(input$selectpoint)))
      else
        updateSpecialPointsList(session, reactiveValuesToList(curveList), 0)

      # Updating the save and delete curve menu
      curtabname <- curveListNames[as.numeric(isolate(input$plottab))]
      updateCurveMenu(session, curveList[[curtabname]])

      # And updating the global CurveList variable
      if (exists("CurveList", envir = .GlobalEnv)) {
        rm("CurveList", envir = .GlobalEnv)
      }
      assign("CurveList", list(Orbits = curveList$Orbits, BifurcationCurves = curveList$BifurcationCurves,
                               BifurcationBounds = curveList$BifurcationBounds, TotalCurves = curveList$TotalCurves),
             envir = .GlobalEnv)
      changeCurveMenu(0)
    })

    # React to changes in consoleLog, by rendering the new text
    observe({
      shinyjs::html(id = "console", html = HTML(gsub("\n", "<br>", consoleLog())))
      session$sendCustomMessage(type = "scrollCallback", 1)
    })

    observe({
      if (as.numeric(curveDirection()) == 0) return(NULL)

      isolate({
        shinyjs::removeClass(selector = "aside.control-sidebar", class = "control-sidebar-open")
        shinyjs::hide(selector = "ul.menu-open");
        shinyjs::removeClass(selector = "li.treeview", class = "active")
        updateSelectInput(session, "deletecurve", selected = 0)

        curtab <- as.numeric(input$plottab)
        curtabname <- curveListNames[curtab]
        pointid <- as.numeric(input$selectpoint)
        curvetype <- ifelse((curtabname == 'BifurcationCurves'), "EQ", input$curvetype)
        clist <- reactiveValuesToList(curveList)
        popts <- reactiveValuesToList(plotopts)
        numopts$stepsize <- as.numeric(curveDirection())*abs(numopts$stepsize)

        # Get the starting point
        if (pointid > 0) {
          ind1 <- round(pointid/1000000)
          ind2 <- round((pointid-ind1*1000000)/1000)
          ind3 <- round(pointid-ind1*1000000-ind2*1000)
          cln1 <- curveListNames[ind1]
          ii <- ifelse((ind1 == 3), 2, 1) # 2 parameter bifurcation points have 2 columns before state, otherwise only 1

          initstate <- as.numeric(clist[[cln1]][[ind2]]$special.points[ind3, (ii + (1:length(state)))])
          initparms <- as.numeric(clist[[cln1]][[ind2]]$parameters)
          inittype <- clist[[cln1]][[ind2]]$special.tags[ind3, "Type"]
          if (inittype != "TS")
            initparms[as.numeric(clist[[cln1]][[ind2]]$bifpars)] <- as.numeric(clist[[cln1]][[ind2]]$special.points[ind3, (1:ii)])
          inittanvec <- clist[[cln1]][[ind2]]$tangent[ind3,]
        } else {
          initstate <- state
          initparms <- parms
          for (i in statenames) initstate[i] <- input[[paste0(i, "_", curtab)]]
          for (i in parmsnames) initparms[i] <- input[[paste0(i, "_", curtab)]]
          inittype <- "US"
          inittanvec <- NULL
        }
        names(initstate) <- names(state)
        names(initparms) <- names(parms)

        newlist <- initCurveContinuation(session, model, initstate, initparms, inittanvec, curtabname, clist,
                                         curvetype, inittype, popts[[curtabname]], numopts, as.numeric(input$reportlevel))
        if (!is.null(newlist)) {
          lapply((1:length(newlist)), function(i) {curveList[[(curveListNames[[i]])]] <- newlist[[(curveListNames[[i]])]]})
          updatePlot(1)
          busyComputing(1)
          updateActionButton(session, "pausebtn", label = "Pause", icon = icon("pause-circle"))
          shinyjs::show("pausebtn")
          shinyjs::show("stopbtn")
        }

        # Update the console log
        consoleLog(session$userData$alltext)
      })
    })

    observe({
      if ((as.numeric(busyComputing()) != 1) || is.null(session$userData$computeSpecs)) return(NULL)

      isolate({
        computeSpecs <- session$userData$computeSpecs
        nsol <- tryCatch(nextCurvePoints(isolate(round(as.numeric(numopts$replotfreq))), session$userData$computeSpecs,
                                         plotopts[[computeSpecs$tabname]], numopts, session = session),
                         warning = function(e) {
                           msg <- gsub(".*:", "Warning in nextCurvePoints:", e)
                           if (!is.null(session)) shinyjs::html(id = "progress", html = HTML(gsub("\n", "<br>", msg)))
                           else cat(msg)
                           session$userData$computeSpecs <- NULL
                           return(NULL)
                         },
                         error = function(e) {
                           msg <- gsub(".*:", "Error in nextCurvePoints:", e)
                           if (!is.null(session)) shinyjs::html(id = "progress", html = HTML(gsub("\n", "<br>", msg)))
                           else cat(msg)
                           session$userData$computeSpecs <- NULL
                           return(NULL)
                         })

        if (!is.null(nsol) && (length(nsol) > 0) && !is.null(nsol$points)) {

          newcurve <- curveList[[computeSpecs$tabname]][[computeSpecs$newcurvenr]]
          newcurve$points <- rbind(newcurve$points, nsol$points)
          newcurve$eigvals <- rbind(newcurve$eigvals, nsol$eigvals)
          newcurve$tangent <- rbind(newcurve$tangent, nsol$tangent)
          newcurve$special.points <- rbind(newcurve$special.points, nsol$special.points)
          newcurve$special.tags <- rbind(newcurve$special.tags, nsol$special.tags)
          newcurve$special.eigvals <- rbind(newcurve$special.eigvals, nsol$special.eigvals)
          newcurve$special.tangent <- rbind(newcurve$special.tangent, nsol$special.tangent)

          curveList[[computeSpecs$tabname]][[computeSpecs$newcurvenr]] <- newcurve
        }
      })

      # Update the console log
      consoleLog(session$userData$alltext)

      # Invalidate this for later if computation has not ended
      if (!is.null(session$userData$computeSpecs)) {
        updatePlot(1)
        invalidateLater(0, session)
      } else {
        changeCurveMenu(1)
        updatePlot(1)
        curveDirection(0)
        busyComputing(0)
        shinyjs::hide("pausebtn")
        shinyjs::hide("stopbtn")
      }
    })

    # observeEvent is non-reactive, it only reacts to invalidation of the specified event
    observeEvent(input$pausebtn, {
      busycomp <- as.numeric(isolate(busyComputing()))
      if (busycomp == 0) return(NULL)
      else if (busycomp == 1) {
        updateActionButton(session, "pausebtn", label = "Continue", icon = icon("forward"))
        busyComputing(-1)
        changeCurveMenu(1)
        updatePlot(1)
      }
      else {
        updateActionButton(session, "pausebtn", label = "Pause", icon = icon("pause-circle"))
        busyComputing(1)
      }
    })

    observeEvent(input$stopbtn, {
      if (as.numeric(isolate(busyComputing())) == 0) return(NULL)
      updateConsoleLog(session, "Computation interrupted by the user\n")

      computeSpecs <- session$userData$computeSpecs

      # Add the final points as special point
      newcurve <- curveList[[computeSpecs$tabname]][[computeSpecs$newcurvenr]]
      if (!is.null(newcurve) && !is.null(newcurve$points)) {
        endPnt <- c("Type" = computeSpecs$curvetype,
                    "Description" = paste(unlist(lapply(1:length(newcurve$points[1,]),
                                                        function(i) {paste0(names(newcurve$points[1,i]), "=",
                                                                            round(newcurve$points[nrow(newcurve$points), i], 3))})),
                                          collapse=', '))
        updateConsoleLog(session, paste("Ended in", endPnt["Description"], "\n", sep=" "))
        endPnt["Description"] <- paste0(sprintf("%04d: ", (computeSpecs$pntnr-1)), endPnt["Description"])

        newcurve$special.points <- rbind(newcurve$special.points, newcurve$points[nrow(newcurve$points),])
        newcurve$special.eigvals <- rbind(newcurve$special.eigvals, newcurve$special.eigvals[nrow(newcurve$special.eigvals),])
        newcurve$special.tangent <- rbind(newcurve$special.tangent, newcurve$special.tangent[nrow(newcurve$special.tangent),])
        newcurve$special.tags <- rbind(newcurve$special.tags, c(endPnt))

        curveList[[computeSpecs$tabname]][[computeSpecs$newcurvenr]] <- newcurve
      }

      session$userData$computeSpecs <- NULL
      changeCurveMenu(1)
      updatePlot(1)
      curveDirection(0)
      busyComputing(0)
      updateActionButton(session, "pausebtn", label = "Pause", icon = icon("pause-circle"))
      shinyjs::hide("pausebtn")
      shinyjs::hide("stopbtn")

      # Update the console log
      consoleLog(session$userData$alltext)
    }, ignoreInit = TRUE)

    observeEvent(input$plottab, {
      curtab <- as.numeric(input$plottab)
      curtabname <- curveListNames[curtab]
      clist <- reactiveValuesToList(curveList)
      popts <- reactiveValuesToList(plotopts)
      plotopts[[curtabname]] <- updatePlotOptionEntries(session, curtab, popts[[curtabname]], statenames, parmsnames)
      updatePlot(1)
      updateCurveMenu(session, curveList[[curtabname]])
    })

    observeEvent(input$selectpoint, {
      curtab <- as.numeric(input$plottab)
      curtabname <- curveListNames[curtab]
      clist <- reactiveValuesToList(curveList)
      updateSelectedPoint(session, curtab, clist, as.numeric(input$selectpoint), statenames, parmsnames)
    })

    observeEvent(c(input$plotoptsapply, input$numoptsapply), {
      shinyjs::removeClass(selector = "aside.control-sidebar", class = "control-sidebar-open")

      curtab <- as.numeric(input$plottab)
      curtabname <- curveListNames[curtab]
      popts <- reactiveValuesToList(plotopts)
      plotopts[[curtabname]] <- processPlotOptionsApply(session, input, curtab, popts[[curtabname]], statenames, parmsnames)
      processNumOptionsApply(session, input, curtab, numopts)
      updatePlot(1)

      # Update the console log
      consoleLog(session$userData$alltext)
    })

    observeEvent(input$computebtn, {
      if (as.numeric(isolate(busyComputing())) != 0) return(NULL)
      shinyjs::removeClass(selector = "aside.control-sidebar", class = "control-sidebar-open")
      shinyjs::hide(selector = "ul.menu-open");
      shinyjs::removeClass(selector = "li.treeview", class = "active")
      updateSelectInput(session, "deletecurve", selected = 0)

      clist <- reactiveValuesToList(curveList)

      initstate <- state
      initparms <- parms
      for (i in statenames) initstate[i] <- input[[paste0(i, "_1")]]
      for (i in parmsnames) initparms[i] <- input[[paste0(i, "_1")]]

      newlist <- processComputeButton(session, model, initstate, initparms, clist, as.numeric(input$selectpoint), numopts)
      if (!is.null(newlist)) lapply((1:length(newlist)),
                                    function(i) {curveList[[(curveListNames[[i]])]] <- newlist[[(curveListNames[[i]])]]})
      changeCurveMenu(1)

      # Update the console log
      consoleLog(session$userData$alltext)
    }, ignoreInit = TRUE)

    observeEvent(c(input$computefwrd2,input$computefwrd3), {
      if (as.numeric(isolate(busyComputing())) != 0) return(NULL)
      curveDirection(1)
    }, ignoreInit = TRUE)

    observeEvent(c(input$computebwrd2,input$computebwrd3), {
      if (as.numeric(isolate(busyComputing())) != 0) return(NULL)
      curveDirection(-1)
    }, ignoreInit = TRUE)

    observeEvent(input$deletebtn, {
      if (as.numeric(isolate(busyComputing())) != 0) return(NULL)
      curtab <- as.numeric(input$plottab)
      curtabname <- curveListNames[curtab]
      curveList[[curtabname]] <- processDeleteCurve(session, curtab, curveList[[curtabname]], as.numeric(input$deletecurve))
      changeCurveMenu(-1)
    })

    observeEvent(input$savebtn, {
      if (as.numeric(isolate(busyComputing())) != 0) return(NULL)
      curtab <- as.numeric(input$plottab)
      curtabname <- curveListNames[curtab]
      processSaveCurve(curtab, curveList[[curtabname]], as.numeric(input$savecurve), make.names(input$curvename, unique = TRUE))
    })

    observeEvent(input$appendbtn, {
      if (as.numeric(isolate(busyComputing())) != 0) return(NULL)
      curtab <- as.numeric(input$plottab)
      clist <- reactiveValuesToList(curveList)
      newlist <- processLoadCurve(session, curtab, clist, input$loadcurve, statenames, parmsnames, replace = FALSE)
      if (!is.null(newlist)) lapply((1:length(newlist)),
                                    function(i) {curveList[[(curveListNames[[i]])]] <- newlist[[(curveListNames[[i]])]]})

      # Update the console log
      consoleLog(session$userData$alltext)
    })

    observeEvent(input$replacebtn, {
      if (as.numeric(isolate(busyComputing())) != 0) return(NULL)
      curtab <- as.numeric(input$plottab)
      clist <- reactiveValuesToList(curveList)
      newlist <- processLoadCurve(session, curtab, clist, input$loadcurve, statenames, parmsnames, replace = TRUE)
      if (!is.null(newlist)) lapply((1:length(newlist)),
                                    function(i) {curveList[[(curveListNames[[i]])]] <- newlist[[(curveListNames[[i]])]]})

      # Update the console log
      consoleLog(session$userData$alltext)
    })
  }

  # output[["console"]] <- renderText({
  #   cnames <- names(cdata)
  #
  #   allvalues <- lapply(cnames, function(name) {
  #     paste(name, cdata[[name]], sep = " = ")
  #   })
  #   paste(allvalues, collapse = "\n")
  # })

  shinyApp(ui = ui, server = server)
}

